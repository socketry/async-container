<!DOCTYPE html>
<html>
	<head>
		
			<title>Async::Container::Controller</title>
		
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		
		<link rel="icon" type="image/png" href="../../../../_static/icon.png"/>
		<link rel="stylesheet" href="../../../../_static/site.css" type="text/css" media="screen"/>
		
		<script src="../../../../_components/jquery/jquery.min.js"></script>
		<script src="../../../../_components/jquery-syntax/jquery.syntax.min.js"></script>
		
		<script type="text/javascript">
		//<![CDATA[
			jQuery(function($) {
				$.syntax();
			});
		//]]>
		</script>
	</head>

	<body class="">
		<nav> › <a class="link" href="../../../../index.html">Project</a> › <a class="link" href="../../../index.html">Source</a></nav>
		
		
	<h1><code class="language-ruby">Async::Container::Controller</code></h1>
	
	<main>
		<p>Manages the life-cycle of one or more containers in order to support a persistent system.
e.g. a web server, job server or some other long running system.</p>
		
		
		<h2>Definitions</h2>
		
		<h3 id="Async::Container::Controller#initialize"><code class="language-ruby">def initialize(notify: Notify.open!)</code></h3><p>Initialize the controller.</p>
<details open>
	<summary><h4>Signature</h4></summary>
	<dl><dt>
					<strong>parameter</strong>　<code class="syntax">notify</code>　<code class="language-ruby">Notify::<a href="../Notify/Client/index.html" title="Async::Container::Notify::Client">Client</a></code></dt><dd><p>A client used for process readiness notifications.</p>
</dd></dl>
</details>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def initialize(notify: Notify.open!)
	@container = nil
	
	if @notify = notify
		@notify.status!(&quot;Initializing...&quot;)
	end
	
	@signals = {}
	
	trap(SIGHUP) do
		self.restart
	end
end</code></pre>
						</details><h3 id="Async::Container::Controller#state_string"><code class="language-ruby">def state_string</code></h3><p>The state of the controller.</p>
<details open>
	<summary><h4>Signature</h4></summary>
	<dl><dt>
					<strong>returns</strong>　<code class="language-ruby">String</code></dt></dl>
</details>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def state_string
	if running?
		&quot;running&quot;
	else
		&quot;stopped&quot;
	end
end</code></pre>
						</details><h3 id="Async::Container::Controller#to_s"><code class="language-ruby">def to_s</code></h3><p>A human readable representation of the controller.</p>
<details open>
	<summary><h4>Signature</h4></summary>
	<dl><dt>
					<strong>returns</strong>　<code class="language-ruby">String</code></dt></dl>
</details>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def to_s
	&quot;#{self.class} #{state_string}&quot;
end</code></pre>
						</details><h3 id="Async::Container::Controller#trap"><code class="language-ruby">def trap(signal, &amp;block)</code></h3><p>Trap the specified signal.</p>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def trap(signal, &amp;block)
	@signals[signal] = block
end</code></pre>
						</details><h3 id="Async::Container::Controller#container"><code class="language-ruby">attr :container</code></h3><p>The current container being managed by the controller.</p>
<h3 id="Async::Container::Controller#create_container"><code class="language-ruby">def create_container</code></h3><p>Create a container for the controller.
Can be overridden by a sub-class.</p>
<details open>
	<summary><h4>Signature</h4></summary>
	<dl><dt>
					<strong>returns</strong>　<code class="language-ruby"><a href="../Generic/index.html" title="Async::Container::Generic">Generic</a></code></dt><dd><p>A specific container instance to use.</p>
</dd></dl>
</details>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def create_container
	Container.new
end</code></pre>
						</details><h3 id="Async::Container::Controller#running?"><code class="language-ruby">def running?</code></h3><p>Whether the controller has a running container.</p>
<details open>
	<summary><h4>Signature</h4></summary>
	<dl><dt>
					<strong>returns</strong>　<code class="language-ruby">Boolean</code></dt></dl>
</details>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def running?
	!!@container
end</code></pre>
						</details><h3 id="Async::Container::Controller#wait"><code class="language-ruby">def wait</code></h3><p>Wait for the underlying container to start.</p>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def wait
	@container&amp;.wait
end</code></pre>
						</details><h3 id="Async::Container::Controller#setup"><code class="language-ruby">def setup(container)</code></h3><p>Spawn container instances into the given container.
Should be overridden by a sub-class.</p>
<details open>
	<summary><h4>Signature</h4></summary>
	<dl><dt>
					<strong>parameter</strong>　<code class="syntax">container</code>　<code class="language-ruby"><a href="../Generic/index.html" title="Async::Container::Generic">Generic</a></code></dt><dd><p>The container, generally from <code class="language-ruby">#create_container</code>.</p>
</dd></dl>
</details>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def setup(container)
	# Don't do this, otherwise calling super is risky for sub-classes:
	# raise NotImplementedError, &quot;Container setup is must be implemented in derived class!&quot;
end</code></pre>
						</details><h3 id="Async::Container::Controller#start"><code class="language-ruby">def start</code></h3><p>Start the container unless it's already running.</p>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def start
	self.restart unless @container
end</code></pre>
						</details><h3 id="Async::Container::Controller#stop"><code class="language-ruby">def stop(graceful = true)</code></h3><p>Stop the container if it's running.</p>
<details open>
	<summary><h4>Signature</h4></summary>
	<dl><dt>
					<strong>parameter</strong>　<code class="syntax">graceful</code>　<code class="language-ruby">Boolean</code></dt><dd><p>Whether to give the children instances time to shut down or to kill them immediately.</p>
</dd></dl>
</details>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def stop(graceful = true)
	@container&amp;.stop(graceful)
	@container = nil
end</code></pre>
						</details><h3 id="Async::Container::Controller#restart"><code class="language-ruby">def restart</code></h3><p>Restart the container. A new container is created, and if successful, any old container is terminated gracefully.</p>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def restart
	if @container
		@notify&amp;.restarting!
		
		Async.logger.debug(self) {&quot;Restarting container...&quot;}
	else
		Async.logger.debug(self) {&quot;Starting container...&quot;}
	end
	
	container = self.create_container
	
	begin
		self.setup(container)
	rescue
		@notify&amp;.error!($!.to_s)
		
		raise SetupError, container
	end
	
	# Wait for all child processes to enter the ready state.
	Async.logger.debug(self, &quot;Waiting for startup...&quot;)
	container.wait_until_ready
	Async.logger.debug(self, &quot;Finished startup.&quot;)
	
	if container.failed?
		@notify&amp;.error!($!.to_s)
		
		container.stop
		
		raise SetupError, container
	end
	
	# Make this swap as atomic as possible:
	old_container = @container
	@container = container
	
	Async.logger.debug(self, &quot;Stopping old container...&quot;)
	old_container&amp;.stop
	@notify&amp;.ready!
rescue
	# If we are leaving this function with an exception, try to kill the container:
	container&amp;.stop(false)
	
	raise
end</code></pre>
						</details><h3 id="Async::Container::Controller#reload"><code class="language-ruby">def reload</code></h3><p>Reload the existing container. Children instances will be reloaded using <code>SIGHUP</code>.</p>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def reload
	@notify&amp;.reloading!
	
	Async.logger.info(self) {&quot;Reloading container: #{@container}...&quot;}
	
	begin
		self.setup(@container)
	rescue
		raise SetupError, container
	end
	
	# Wait for all child processes to enter the ready state.
	Async.logger.debug(self, &quot;Waiting for startup...&quot;)
	@container.wait_until_ready
	Async.logger.debug(self, &quot;Finished startup.&quot;)
	
	if @container.failed?
		@notify.error!(&quot;Container failed!&quot;)
		
		raise SetupError, @container
	else
		@notify&amp;.ready!
	end
end</code></pre>
						</details><h3 id="Async::Container::Controller#run"><code class="language-ruby">def run</code></h3><p>Enter the controller run loop, trapping <code>SIGINT</code> and <code>SIGTERM</code>.</p>
<details>
							<summary><h4>Implementation</h4></summary>
							<pre><code class="language-ruby">def run
	# I thought this was the default... but it doesn't always raise an exception unless you do this explicitly.
	interrupt_action = Signal.trap(:INT) do
		raise Interrupt
	end
	
	terminate_action = Signal.trap(:TERM) do
		raise Terminate
	end
	
	self.start
	
	while @container&amp;.running?
		begin
			@container.wait
		rescue SignalException =&gt; exception
			if handler = @signals[exception.signo]
				begin
					handler.call
				rescue SetupError =&gt; error
					Async.logger.error(self) {error}
				end
			else
				raise
			end
		end
	end
rescue Interrupt
	self.stop(true)
rescue Terminate
	self.stop(false)
ensure
	self.stop(true)
	
	# Restore the interrupt handler:
	Signal.trap(:INT, interrupt_action)
	Signal.trap(:TERM, terminate_action)
end</code></pre>
						</details>	</main>

		
		<footer>Documentation generated by <a href="https://github.com/socketry/utopia-project">Utopia::Project</a>.</footer>
	</body>
</html>