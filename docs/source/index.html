<!DOCTYPE html>
<html>
	<head>
		
			<title>Source</title>
		
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		
		<link rel="icon" type="image/png" href="../_static/icon.png"/>
		<link rel="stylesheet" href="../_static/site.css" type="text/css" media="screen"/>
		
		<script src="../_components/jquery/jquery.min.js"></script>
		<script src="../_components/jquery-syntax/jquery.syntax.min.js"></script>
		
		<script type="text/javascript">
		//<![CDATA[
			jQuery(function($) {
				$.syntax();
			});
		//]]>
		</script>
	</head>

	<body class="">
		<nav> › <a class="link" href="../index.html">Project</a> › <a class="link" href="index.html">Source</a></nav>
		
		
	<h1>Source</h1>
	
	<main>
		<ul class="index"><li>
						<a href="Async/index.html"><code class="language-ruby">module Async</code></a>
						
						
						<ul class="index"><li>
						<a href="Async/Container/index.html"><code class="language-ruby">module Container</code></a>
						
						
						<ul class="index"><li>
						<a href="Async/Container/Notify/index.html"><code class="language-ruby">module Notify</code></a>
						
							<p>Handles the details of several process readiness protocols.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Notify/Pipe/index.html"><code class="language-ruby">class Pipe &lt; Client</code></a>
						
							<p>Implements a process readiness protocol using an inherited pipe file descriptor.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Notify/Pipe/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3APipe%3A%3ANOTIFY_PIPE"><code class="language-ruby">NOTIFY_PIPE = 'NOTIFY_PIPE'</code></a>
						
							<p>The environment variable key which contains the pipe file descriptor.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Pipe/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3APipe.open%21"><code class="language-ruby">def self.open!(environment = ENV)</code></a>
						
							<p>Open a notification client attached to the current <a href="Async/Container/Notify/Pipe/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3APipe%3A%3ANOTIFY_PIPE" title="NOTIFY_PIPE"><code class="language-ruby">NOTIFY_PIPE = 'NOTIFY_PIPE'</code></a> if possible.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Pipe/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3APipe%23initialize"><code class="language-ruby">def initialize(io)</code></a>
						
							<p>Initialize the notification client.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Pipe/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3APipe%23before_spawn"><code class="language-ruby">def before_spawn(arguments, options)</code></a>
						
							<p>Inserts or duplicates the environment given an argument array.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Pipe/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3APipe%23send"><code class="language-ruby">def send(**message)</code></a>
						
							<p>Formats the message using JSON and sends it to the parent controller.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Notify/Socket/index.html"><code class="language-ruby">class Socket &lt; Client</code></a>
						
							<p>Implements the systemd NOTIFY_SOCKET process readiness protocol.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Notify/Socket/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3ASocket%3A%3ANOTIFY_SOCKET"><code class="language-ruby">NOTIFY_SOCKET = 'NOTIFY_SOCKET'</code></a>
						
							<p>The name of the environment variable which contains the path to the notification socket.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Socket/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3ASocket%3A%3AMAXIMUM_MESSAGE_SIZE"><code class="language-ruby">MAXIMUM_MESSAGE_SIZE = 4096</code></a>
						
							<p>The maximum allowed size of the UDP message.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Socket/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3ASocket.open%21"><code class="language-ruby">def self.open!(environment = ENV)</code></a>
						
							<p>Open a notification client attached to the current <a href="Async/Container/Notify/Socket/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3ASocket%3A%3ANOTIFY_SOCKET" title="NOTIFY_SOCKET"><code class="language-ruby">NOTIFY_SOCKET = 'NOTIFY_SOCKET'</code></a> if possible.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Socket/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3ASocket%23initialize"><code class="language-ruby">def initialize(path)</code></a>
						
							<p>Initialize the notification client.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Socket/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3ASocket%23dump"><code class="language-ruby">def dump(message)</code></a>
						
							<p>Dump a message in the format requied by <code>sd_notify</code>.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Socket/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3ASocket%23send"><code class="language-ruby">def send(**message)</code></a>
						
							<p>Send the given message.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Socket/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3ASocket%23error%21"><code class="language-ruby">def error!(text, **message)</code></a>
						
							<p>Send the specified error.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Notify/Client/index.html"><code class="language-ruby">class Client</code></a>
						
						
						<ul class="index"><li>
						<a href="Async/Container/Notify/Client/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3AClient%23ready%21"><code class="language-ruby">def ready!(**message)</code></a>
						
							<p>Notify the parent controller that the child has become ready, with a brief status message.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Client/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3AClient%23reloading%21"><code class="language-ruby">def reloading!(**message)</code></a>
						
							<p>Notify the parent controller that the child is reloading.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Client/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3AClient%23restarting%21"><code class="language-ruby">def restarting!(**message)</code></a>
						
							<p>Notify the parent controller that the child is restarting.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Client/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3AClient%23stopping%21"><code class="language-ruby">def stopping!(**message)</code></a>
						
							<p>Notify the parent controller that the child is stopping.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Client/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3AClient%23status%21"><code class="language-ruby">def status!(text)</code></a>
						
							<p>Notify the parent controller of a status change.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Client/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3AClient%23error%21"><code class="language-ruby">def error!(text, **message)</code></a>
						
							<p>Notify the parent controller of an error condition.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Notify/Server/index.html"><code class="language-ruby">class Server</code></a>
						
						
						<ul class="index"><li>
						<a href="Async/Container/Notify/Server/Context/index.html"><code class="language-ruby">class Context</code></a>
						
						
						<ul class="index"></ul>					</li></ul>					</li><li>
						<a href="Async/Container/Notify/Console/index.html"><code class="language-ruby">class Console &lt; Client</code></a>
						
							<p>Implements a general process readiness protocol with output to the local console.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Notify/Console/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3AConsole.open%21"><code class="language-ruby">def self.open!(logger = ::Console.logger)</code></a>
						
							<p>Open a notification client attached to the current console.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Console/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3AConsole%23initialize"><code class="language-ruby">def initialize(logger)</code></a>
						
							<p>Initialize the notification client.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Console/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3AConsole%23send"><code class="language-ruby">def send(level: :debug, **message)</code></a>
						
							<p>Send a message to the console.</p>

						
											</li><li>
						<a href="Async/Container/Notify/Console/index.html#Async%3A%3AContainer%3A%3ANotify%3A%3AConsole%23error%21"><code class="language-ruby">def error!(text, **message)</code></a>
						
							<p>Send an error message to the console.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Notify/index.html#Async%3A%3AContainer%3A%3ANotify.open%21"><code class="language-ruby">def self.open!</code></a>
						
							<p>Select the best available notification client.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Statistics/index.html"><code class="language-ruby">class Statistics</code></a>
						
							<p>Tracks various statistics relating to child instances in a container.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Statistics/index.html#Async%3A%3AContainer%3A%3AStatistics%23spawns"><code class="language-ruby">attr :spawns</code></a>
						
							<p>How many child instances have been spawned.</p>

						
											</li><li>
						<a href="Async/Container/Statistics/index.html#Async%3A%3AContainer%3A%3AStatistics%23restarts"><code class="language-ruby">attr :restarts</code></a>
						
							<p>How many child instances have been restarted.</p>

						
											</li><li>
						<a href="Async/Container/Statistics/index.html#Async%3A%3AContainer%3A%3AStatistics%23failures"><code class="language-ruby">attr :failures</code></a>
						
							<p>How many child instances have failed.</p>

						
											</li><li>
						<a href="Async/Container/Statistics/index.html#Async%3A%3AContainer%3A%3AStatistics%23spawn%21"><code class="language-ruby">def spawn!</code></a>
						
							<p>Increment the number of spawns by 1.</p>

						
											</li><li>
						<a href="Async/Container/Statistics/index.html#Async%3A%3AContainer%3A%3AStatistics%23restart%21"><code class="language-ruby">def restart!</code></a>
						
							<p>Increment the number of restarts by 1.</p>

						
											</li><li>
						<a href="Async/Container/Statistics/index.html#Async%3A%3AContainer%3A%3AStatistics%23failure%21"><code class="language-ruby">def failure!</code></a>
						
							<p>Increment the number of failures by 1.</p>

						
											</li><li>
						<a href="Async/Container/Statistics/index.html#Async%3A%3AContainer%3A%3AStatistics%23failed%3F"><code class="language-ruby">def failed?</code></a>
						
							<p>Whether there have been any failures.</p>

						
											</li><li>
						<a href="Async/Container/Statistics/index.html#Async%3A%3AContainer%3A%3AStatistics%23%3C%3C"><code class="language-ruby">def &lt;&lt; other</code></a>
						
							<p>Append another statistics instance into this one.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/index.html#Async%3A%3AContainer.fork%3F"><code class="language-ruby">def self.fork?</code></a>
						
							<p>Whether the underlying process supports fork.</p>

						
											</li><li>
						<a href="Async/Container/index.html#Async%3A%3AContainer.best_container_class"><code class="language-ruby">def self.best_container_class</code></a>
						
							<p>Determins the best container class based on the underlying Ruby implementation.</p>

						
											</li><li>
						<a href="Async/Container/index.html#Async%3A%3AContainer.new"><code class="language-ruby">def self.new(*arguments, **options)</code></a>
						
							<p>Create an instance of the best container class.</p>

						
											</li><li>
						<a href="Async/Container/Process/index.html"><code class="language-ruby">class Process &lt; Channel</code></a>
						
							<p>Represents a running child process from the point of view of the parent container.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Process/Instance/index.html"><code class="language-ruby">class Instance &lt; Notify::Pipe</code></a>
						
							<p>Represents a running child process from the point of view of the child process.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Process/Instance/index.html#Async%3A%3AContainer%3A%3AProcess%3A%3AInstance.for"><code class="language-ruby">def self.for(process)</code></a>
						
							<p>Wrap an instance around the <a href="Async/Container/Process/index.html" title="Process"><code class="language-ruby">class Async::Container::Process</code></a> instance from within the forked child.</p>

						
											</li><li>
						<a href="Async/Container/Process/Instance/index.html#Async%3A%3AContainer%3A%3AProcess%3A%3AInstance%23name%3D"><code class="language-ruby">def name= value</code></a>
						
							<p>Set the process title to the specified value.</p>

						
											</li><li>
						<a href="Async/Container/Process/Instance/index.html#Async%3A%3AContainer%3A%3AProcess%3A%3AInstance%23name"><code class="language-ruby">def name</code></a>
						
							<p>The name of the process.</p>

						
											</li><li>
						<a href="Async/Container/Process/Instance/index.html#Async%3A%3AContainer%3A%3AProcess%3A%3AInstance%23exec"><code class="language-ruby">def exec(*arguments, ready: true, **options)</code></a>
						
							<p>Replace the current child process with a different one. Forwards arguments and options to <code class="language-ruby">::Process.exec</code>.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Process/index.html#Async%3A%3AContainer%3A%3AProcess.fork"><code class="language-ruby">def self.fork(**options)</code></a>
						
							<p>Fork a child process appropriate for a container.</p>

						
											</li><li>
						<a href="Async/Container/Process/index.html#Async%3A%3AContainer%3A%3AProcess%23initialize"><code class="language-ruby">def initialize(name: nil)</code></a>
						
							<p>Initialize the process.</p>

						
											</li><li>
						<a href="Async/Container/Process/index.html#Async%3A%3AContainer%3A%3AProcess%23name%3D"><code class="language-ruby">def name= value</code></a>
						
							<p>Set the name of the process.</p>

						
											</li><li>
						<a href="Async/Container/Process/index.html#Async%3A%3AContainer%3A%3AProcess%23name"><code class="language-ruby">attr :name</code></a>
						
							<p>The name of the process.</p>

						
											</li><li>
						<a href="Async/Container/Process/index.html#Async%3A%3AContainer%3A%3AProcess%23to_s"><code class="language-ruby">def to_s</code></a>
						
							<p>A human readable representation of the process.</p>

						
											</li><li>
						<a href="Async/Container/Process/index.html#Async%3A%3AContainer%3A%3AProcess%23close"><code class="language-ruby">def close</code></a>
						
							<p>Invoke <code class="language-ruby">#terminate!</code> and then <code class="language-ruby">#wait</code> for the child process to exit.</p>

						
											</li><li>
						<a href="Async/Container/Process/index.html#Async%3A%3AContainer%3A%3AProcess%23interrupt%21"><code class="language-ruby">def interrupt!</code></a>
						
							<p>Send <code>SIGINT</code> to the child process.</p>

						
											</li><li>
						<a href="Async/Container/Process/index.html#Async%3A%3AContainer%3A%3AProcess%23terminate%21"><code class="language-ruby">def terminate!</code></a>
						
							<p>Send <code>SIGTERM</code> to the child process.</p>

						
											</li><li>
						<a href="Async/Container/Process/index.html#Async%3A%3AContainer%3A%3AProcess%23wait"><code class="language-ruby">def wait</code></a>
						
							<p>Wait for the child process to exit.</p>

						
											</li></ul>					</li><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index"><code class="language-ruby">class Group</code></a>
						
							<p>Manages a group of running processes.</p>

						
						<ul class="index"><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index#Async%3A%3AContainer%3A%3AGroup%23initialize"><code class="language-ruby">def initialize</code></a>
						
							<p>Initialize an empty group.</p>

						
											</li><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index#Async%3A%3AContainer%3A%3AGroup%23running"><code class="language-ruby">attr :running</code></a>
						
						
											</li><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index#Async%3A%3AContainer%3A%3AGroup%23running%3F"><code class="language-ruby">def running?</code></a>
						
							<p>Whether the group contains any running processes.</p>

						
											</li><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index#Async%3A%3AContainer%3A%3AGroup%23any%3F"><code class="language-ruby">def any?</code></a>
						
							<p>Whether the group contains any running processes.</p>

						
											</li><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index#Async%3A%3AContainer%3A%3AGroup%23empty%3F"><code class="language-ruby">def empty?</code></a>
						
							<p>Whether the group is empty.</p>

						
											</li><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index#Async%3A%3AContainer%3A%3AGroup%23sleep"><code class="language-ruby">def sleep(duration)</code></a>
						
							<p>Sleep for at most the specified duration until some state change occurs.</p>

						
											</li><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index#Async%3A%3AContainer%3A%3AGroup%23wait"><code class="language-ruby">def wait</code></a>
						
							<p>Begin any outstanding queued processes and wait for them indefinitely.</p>

						
											</li><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index#Async%3A%3AContainer%3A%3AGroup%23interrupt"><code class="language-ruby">def interrupt</code></a>
						
							<p>Interrupt all running processes.</p>

						
											</li><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index#Async%3A%3AContainer%3A%3AGroup%23terminate"><code class="language-ruby">def terminate</code></a>
						
							<p>Terminate all running processes.</p>

						
											</li><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index#Async%3A%3AContainer%3A%3AGroup%23stop"><code class="language-ruby">def stop(timeout = 1)</code></a>
						
							<p>Stop all child processes using <code class="language-ruby">#terminate</code>.</p>

						
											</li><li>
						<a href="http://localhost:55739/source/Async/Container/Group/index#Async%3A%3AContainer%3A%3AGroup%23wait_for"><code class="language-ruby">def wait_for(channel)</code></a>
						
							<p>Wait for a message in the specified <a href="Async/Container/Channel/index.html" title="Channel"><code class="language-ruby">class Async::Container::Channel</code></a>.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Forked/index.html"><code class="language-ruby">class Forked &lt; Generic</code></a>
						
							<p>A multi-process container which uses <a href="Async/Container/Process/index.html#Async%3A%3AContainer%3A%3AProcess.fork" title="Process.fork"><code class="language-ruby">Async::Container::Process.fork</code></a>.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Forked/index.html#Async%3A%3AContainer%3A%3AForked.multiprocess%3F"><code class="language-ruby">def self.multiprocess?</code></a>
						
							<p>Indicates that this is a multi-process container.</p>

						
											</li><li>
						<a href="Async/Container/Forked/index.html#Async%3A%3AContainer%3A%3AForked%23start"><code class="language-ruby">def start(name, &amp;block)</code></a>
						
							<p>Start a named child process and execute the provided block in it.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Hybrid/index.html"><code class="language-ruby">class Hybrid &lt; Forked</code></a>
						
							<p>Provides a hybrid multi-process multi-thread container.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Hybrid/index.html#Async%3A%3AContainer%3A%3AHybrid%23run"><code class="language-ruby">def run(count: nil, forks: nil, threads: nil, **options, &amp;block)</code></a>
						
							<p>Run multiple instances of the same block in the container.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Channel/index.html"><code class="language-ruby">class Channel</code></a>
						
							<p>Provides a basic multi-thread/multi-process uni-directional communication channel.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Channel/index.html#Async%3A%3AContainer%3A%3AChannel%23initialize"><code class="language-ruby">def initialize</code></a>
						
							<p>Initialize the channel using a pipe.</p>

						
											</li><li>
						<a href="Async/Container/Channel/index.html#Async%3A%3AContainer%3A%3AChannel%23in"><code class="language-ruby">attr :in</code></a>
						
							<p>The input end of the pipe.</p>

						
											</li><li>
						<a href="Async/Container/Channel/index.html#Async%3A%3AContainer%3A%3AChannel%23out"><code class="language-ruby">attr :out</code></a>
						
							<p>The output end of the pipe.</p>

						
											</li><li>
						<a href="Async/Container/Channel/index.html#Async%3A%3AContainer%3A%3AChannel%23close_read"><code class="language-ruby">def close_read</code></a>
						
							<p>Close the input end of the pipe.</p>

						
											</li><li>
						<a href="Async/Container/Channel/index.html#Async%3A%3AContainer%3A%3AChannel%23close_write"><code class="language-ruby">def close_write</code></a>
						
							<p>Close the output end of the pipe.</p>

						
											</li><li>
						<a href="Async/Container/Channel/index.html#Async%3A%3AContainer%3A%3AChannel%23close"><code class="language-ruby">def close</code></a>
						
							<p>Close both ends of the pipe.</p>

						
											</li><li>
						<a href="Async/Container/Channel/index.html#Async%3A%3AContainer%3A%3AChannel%23receive"><code class="language-ruby">def receive</code></a>
						
							<p>Receive an object from the pipe.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/index.html#Async%3A%3AContainer%3A%3AASYNC_CONTAINER_PROCESSOR_COUNT"><code class="language-ruby">ASYNC_CONTAINER_PROCESSOR_COUNT = 'ASYNC_CONTAINER_PROCESSOR_COUNT'</code></a>
						
							<p>An environment variable key to override <code class="language-ruby">.processor_count</code>.</p>

						
											</li><li>
						<a href="Async/Container/index.html#Async%3A%3AContainer.processor_count"><code class="language-ruby">def self.processor_count(env = ENV)</code></a>
						
							<p>The processor count which may be used for the default number of container threads/processes. You can override the value provided by the system by specifying the <code>ASYNC_CONTAINER_PROCESSOR_COUNT</code> environment variable.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html"><code class="language-ruby">class Generic</code></a>
						
							<p>A base class for implementing containers.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23run"><code class="language-ruby">def run(count: Container.processor_count, **options, &amp;block)</code></a>
						
							<p>Run multiple instances of the same block in the container.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23to_s"><code class="language-ruby">def to_s</code></a>
						
							<p>A human readable representation of the container.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23%5B%5D"><code class="language-ruby">def [] key</code></a>
						
							<p>Look up a child process by key.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23statistics"><code class="language-ruby">attr :statistics</code></a>
						
							<p>Statistics relating to the behavior of children instances.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23failed%3F"><code class="language-ruby">def failed?</code></a>
						
							<p>Whether any failures have occurred within the container.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23running%3F"><code class="language-ruby">def running?</code></a>
						
							<p>Whether the container has running children instances.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23sleep"><code class="language-ruby">def sleep(duration = nil)</code></a>
						
							<p>Sleep until some state change occurs.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23wait"><code class="language-ruby">def wait</code></a>
						
							<p>Wait until all spawned tasks are completed.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23status%3F"><code class="language-ruby">def status?(flag)</code></a>
						
							<p>Returns true if all children instances have the specified status flag set.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23wait_until_ready"><code class="language-ruby">def wait_until_ready</code></a>
						
							<p>Wait until all the children instances have indicated that they are ready.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23stop"><code class="language-ruby">def stop(timeout = true)</code></a>
						
							<p>Stop the children instances.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23spawn"><code class="language-ruby">def spawn(name: nil, restart: false, key: nil, &amp;block)</code></a>
						
							<p>Spawn a child instance into the container.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23async"><code class="language-ruby">def async(**options, &amp;block)</code></a>
						
						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23reload"><code class="language-ruby">def reload</code></a>
						
							<p>Reload the container's keyed instances.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23mark%3F"><code class="language-ruby">def mark?(key)</code></a>
						
							<p>Mark the container's keyed instance which ensures that it won't be discarded.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23key%3F"><code class="language-ruby">def key?(key)</code></a>
						
							<p>Whether a child instance exists for the given key.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23insert"><code class="language-ruby">def insert(key, child)</code></a>
						
							<p>Register the child (value) as running.</p>

						
											</li><li>
						<a href="Async/Container/Generic/index.html#Async%3A%3AContainer%3A%3AGeneric%23delete"><code class="language-ruby">def delete(key, child)</code></a>
						
							<p>Clear the child (value) as running.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Error/index.html"><code class="language-ruby">class Error &lt; StandardError</code></a>
						
						
						<ul class="index"></ul>					</li><li>
						<a href="Async/Container/Terminate/index.html"><code class="language-ruby">class Terminate &lt; SignalException</code></a>
						
							<p>Similar to <a href="Async/Container/index.html#Async%3A%3AContainer%3A%3AInterrupt" title="Interrupt"><code class="language-ruby">Interrupt = ::Interrupt</code></a>, but represents <code>SIGTERM</code>.</p>

						
						<ul class="index"></ul>					</li><li>
						<a href="Async/Container/SetupError/index.html"><code class="language-ruby">class SetupError &lt; Error</code></a>
						
							<p>Represents the error which occured when a container failed to start up correctly.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/SetupError/index.html#Async%3A%3AContainer%3A%3ASetupError%23container"><code class="language-ruby">attr :container</code></a>
						
							<p>The container that failed.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Controller/index.html"><code class="language-ruby">class Controller</code></a>
						
							<p>Manages the life-cycle of one or more containers in order to support a persistent system.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23initialize"><code class="language-ruby">def initialize(notify: Notify.open!)</code></a>
						
							<p>Initialize the controller.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23state_string"><code class="language-ruby">def state_string</code></a>
						
							<p>The state of the controller.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23to_s"><code class="language-ruby">def to_s</code></a>
						
							<p>A human readable representation of the controller.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23trap"><code class="language-ruby">def trap(signal, &amp;block)</code></a>
						
							<p>Trap the specified signal.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23container"><code class="language-ruby">attr :container</code></a>
						
							<p>The current container being managed by the controller.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23create_container"><code class="language-ruby">def create_container</code></a>
						
							<p>Create a container for the controller.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23running%3F"><code class="language-ruby">def running?</code></a>
						
							<p>Whether the controller has a running container.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23wait"><code class="language-ruby">def wait</code></a>
						
							<p>Wait for the underlying container to start.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23setup"><code class="language-ruby">def setup(container)</code></a>
						
							<p>Spawn container instances into the given container.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23start"><code class="language-ruby">def start</code></a>
						
							<p>Start the container unless it's already running.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23stop"><code class="language-ruby">def stop(graceful = true)</code></a>
						
							<p>Stop the container if it's running.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23restart"><code class="language-ruby">def restart</code></a>
						
							<p>Restart the container. A new container is created, and if successful, any old container is terminated gracefully.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23reload"><code class="language-ruby">def reload</code></a>
						
							<p>Reload the existing container. Children instances will be reloaded using <code>SIGHUP</code>.</p>

						
											</li><li>
						<a href="Async/Container/Controller/index.html#Async%3A%3AContainer%3A%3AController%23run"><code class="language-ruby">def run</code></a>
						
							<p>Enter the controller run loop, trapping <code>SIGINT</code> and <code>SIGTERM</code>.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Thread/index.html"><code class="language-ruby">class Thread &lt; Channel</code></a>
						
							<p>Represents a running child thread from the point of view of the parent container.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Thread/Exit/index.html"><code class="language-ruby">class Exit &lt; Exception</code></a>
						
							<p>Used to propagate the exit status of a child process invoked by <a href="Async/Container/Thread/Instance/index.html#Async%3A%3AContainer%3A%3AThread%3A%3AInstance%23exec" title="Instance#exec"><code class="language-ruby">Async::Container::Thread::Instance#exec</code></a>.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Thread/Exit/index.html#Async%3A%3AContainer%3A%3AThread%3A%3AExit%23initialize"><code class="language-ruby">def initialize(status)</code></a>
						
							<p>Initialize the exit status.</p>

						
											</li><li>
						<a href="Async/Container/Thread/Exit/index.html#Async%3A%3AContainer%3A%3AThread%3A%3AExit%23status"><code class="language-ruby">attr :status</code></a>
						
							<p>The process exit status.</p>

						
											</li><li>
						<a href="Async/Container/Thread/Exit/index.html#Async%3A%3AContainer%3A%3AThread%3A%3AExit%23error"><code class="language-ruby">def error</code></a>
						
							<p>The process exit status if it was an error.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Thread/Instance/index.html"><code class="language-ruby">class Instance &lt; Notify::Pipe</code></a>
						
							<p>Represents a running child thread from the point of view of the child thread.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Thread/Instance/index.html#Async%3A%3AContainer%3A%3AThread%3A%3AInstance.for"><code class="language-ruby">def self.for(thread)</code></a>
						
							<p>Wrap an instance around the <a href="Async/Container/Thread/index.html" title="Thread"><code class="language-ruby">class Async::Container::Thread</code></a> instance from within the threaded child.</p>

						
											</li><li>
						<a href="Async/Container/Thread/Instance/index.html#Async%3A%3AContainer%3A%3AThread%3A%3AInstance%23name%3D"><code class="language-ruby">def name= value</code></a>
						
							<p>Set the name of the thread.</p>

						
											</li><li>
						<a href="Async/Container/Thread/Instance/index.html#Async%3A%3AContainer%3A%3AThread%3A%3AInstance%23name"><code class="language-ruby">def name</code></a>
						
							<p>Get the name of the thread.</p>

						
											</li><li>
						<a href="Async/Container/Thread/Instance/index.html#Async%3A%3AContainer%3A%3AThread%3A%3AInstance%23exec"><code class="language-ruby">def exec(*arguments, ready: true, **options)</code></a>
						
							<p>Execute a child process using <code class="language-ruby">::Process.spawn</code>. In order to simulate <code class="language-ruby">::Process.exec</code>, an <a href="Async/Container/Thread/Exit/index.html" title="Exit"><code class="language-ruby">class Async::Container::Thread::Exit</code></a> instance is raised to propagage exit status.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Thread/index.html#Async%3A%3AContainer%3A%3AThread%23initialize"><code class="language-ruby">def initialize(name: nil)</code></a>
						
							<p>Initialize the thread.</p>

						
											</li><li>
						<a href="Async/Container/Thread/index.html#Async%3A%3AContainer%3A%3AThread%23name%3D"><code class="language-ruby">def name= value</code></a>
						
							<p>Set the name of the thread.</p>

						
											</li><li>
						<a href="Async/Container/Thread/index.html#Async%3A%3AContainer%3A%3AThread%23name"><code class="language-ruby">def name</code></a>
						
							<p>Get the name of the thread.</p>

						
											</li><li>
						<a href="Async/Container/Thread/index.html#Async%3A%3AContainer%3A%3AThread%23to_s"><code class="language-ruby">def to_s</code></a>
						
							<p>A human readable representation of the thread.</p>

						
											</li><li>
						<a href="Async/Container/Thread/index.html#Async%3A%3AContainer%3A%3AThread%23close"><code class="language-ruby">def close</code></a>
						
							<p>Invoke <code class="language-ruby">#terminate!</code> and then <code class="language-ruby">#wait</code> for the child thread to exit.</p>

						
											</li><li>
						<a href="Async/Container/Thread/index.html#Async%3A%3AContainer%3A%3AThread%23interrupt%21"><code class="language-ruby">def interrupt!</code></a>
						
							<p>Raise <a href="Async/Container/index.html#Async%3A%3AContainer%3A%3AInterrupt" title="Interrupt"><code class="language-ruby">Interrupt = ::Interrupt</code></a> in the child thread.</p>

						
											</li><li>
						<a href="Async/Container/Thread/index.html#Async%3A%3AContainer%3A%3AThread%23terminate%21"><code class="language-ruby">def terminate!</code></a>
						
							<p>Raise <a href="Async/Container/Terminate/index.html" title="Terminate"><code class="language-ruby">class Async::Container::Terminate</code></a> in the child thread.</p>

						
											</li><li>
						<a href="Async/Container/Thread/index.html#Async%3A%3AContainer%3A%3AThread%23wait"><code class="language-ruby">def wait</code></a>
						
							<p>Wait for the thread to exit and return he exit status.</p>

						
											</li><li>
						<a href="Async/Container/Thread/Status/index.html"><code class="language-ruby">class Status</code></a>
						
							<p>A pseudo exit-status wrapper.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Thread/Status/index.html#Async%3A%3AContainer%3A%3AThread%3A%3AStatus%23initialize"><code class="language-ruby">def initialize(error = nil)</code></a>
						
							<p>Initialise the status.</p>

						
											</li><li>
						<a href="Async/Container/Thread/Status/index.html#Async%3A%3AContainer%3A%3AThread%3A%3AStatus%23success%3F"><code class="language-ruby">def success?</code></a>
						
							<p>Whether the status represents a successful outcome.</p>

						
											</li><li>
						<a href="Async/Container/Thread/Status/index.html#Async%3A%3AContainer%3A%3AThread%3A%3AStatus%23to_s"><code class="language-ruby">def to_s</code></a>
						
							<p>A human readable representation of the status.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Thread/index.html#Async%3A%3AContainer%3A%3AThread%23finished"><code class="language-ruby">def finished(error = nil)</code></a>
						
							<p>Invoked by the @waiter thread to indicate the outcome of the child thread.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Threaded/index.html"><code class="language-ruby">class Threaded &lt; Generic</code></a>
						
							<p>A multi-thread container which uses <a href="Async/Container/Thread/index.html#Async%3A%3AContainer%3A%3AThread.fork" title="Thread.fork"><code class="language-ruby">Async::Container::Thread.fork</code></a>.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Threaded/index.html#Async%3A%3AContainer%3A%3AThreaded.multiprocess%3F"><code class="language-ruby">def self.multiprocess?</code></a>
						
							<p>Indicates that this is not a multi-process container.</p>

						
											</li><li>
						<a href="Async/Container/Threaded/index.html#Async%3A%3AContainer%3A%3AThreaded%23start"><code class="language-ruby">def start(name, &amp;block)</code></a>
						
							<p>Start a named child thread and execute the provided block in it.</p>

						
											</li></ul>					</li><li>
						<a href="Async/Container/Keyed/index.html"><code class="language-ruby">class Keyed</code></a>
						
							<p>Tracks a key/value pair such that unmarked keys can be identified and cleaned up.</p>

						
						<ul class="index"><li>
						<a href="Async/Container/Keyed/index.html#Async%3A%3AContainer%3A%3AKeyed%23key"><code class="language-ruby">attr :key</code></a>
						
							<p>The key. Normally a symbol or a file-system path.</p>

						
											</li><li>
						<a href="Async/Container/Keyed/index.html#Async%3A%3AContainer%3A%3AKeyed%23value"><code class="language-ruby">attr :value</code></a>
						
							<p>The value. Normally a child instance of some sort.</p>

						
											</li><li>
						<a href="Async/Container/Keyed/index.html#Async%3A%3AContainer%3A%3AKeyed%23marked%3F"><code class="language-ruby">def marked?</code></a>
						
							<p>Has the instance been marked?</p>

						
											</li><li>
						<a href="Async/Container/Keyed/index.html#Async%3A%3AContainer%3A%3AKeyed%23mark%21"><code class="language-ruby">def mark!</code></a>
						
							<p>Mark the instance. This will indiciate that the value is still in use/active.</p>

						
											</li><li>
						<a href="Async/Container/Keyed/index.html#Async%3A%3AContainer%3A%3AKeyed%23clear%21"><code class="language-ruby">def clear!</code></a>
						
							<p>Clear the instance. This is normally done before reloading a container.</p>

						
											</li><li>
						<a href="Async/Container/Keyed/index.html#Async%3A%3AContainer%3A%3AKeyed%23stop%3F"><code class="language-ruby">def stop?</code></a>
						
							<p>Stop the instance if it was not marked.</p>

						
											</li></ul>					</li></ul>					</li></ul>					</li></ul>	</main>

		
		<footer>Documentation generated by <a href="https://github.com/socketry/utopia-project">Utopia::Project</a>.</footer>
	</body>
</html>